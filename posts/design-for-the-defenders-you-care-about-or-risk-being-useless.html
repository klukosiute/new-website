<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design for the defenders you care about or risk being useless - Kamilė Lukošiūtė</title>
    <meta name="description" content="On operational constraints">

    <!-- Open Graph / Social Cards -->
    <meta property="og:title" content="Design for the defenders you care about or risk being useless">
    <meta property="og:description" content="On operational constraints">
    <meta property="og:image" content="/images/defense_card.png">
    <meta property="og:type" content="article">

    <!-- KaTeX for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            font-size: 16px;
            line-height: 1.7;
            color: #222;
            background: #fff;
            padding: 20px;
        }

        .container {
            max-width: 640px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 2em;
            padding-bottom: 1em;
            border-bottom: 1px solid #ddd;
        }

        header a {
            color: #222;
            text-decoration: none;
        }

        header a:hover {
            text-decoration: underline;
        }

        h1 {
            font-size: 2em;
            margin: 0.67em 0 0.3em 0;
            font-weight: bold;
            line-height: 1.2;
        }

        h2 {
            font-size: 1.5em;
            margin: 0.83em 0;
            font-weight: bold;
            line-height: 1.2;
        }

        h3 {
            font-size: 1.25em;
            margin: 1em 0;
            font-weight: bold;
            line-height: 1.2;
        }

        p {
            margin-bottom: 0.75em;
        }

        a {
            color: #0000EE;
            text-decoration: underline;
        }

        a:visited {
            color: #551A8B;
        }

        a:hover {
            color: #0000EE;
        }

        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            background: #f5f5f5;
            padding: 2px 5px;
            border-radius: 3px;
        }

        pre {
            background: #f5f5f5;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
            border-radius: 5px;
        }

        pre code {
            background: none;
            padding: 0;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 1.5em auto;
        }

        blockquote {
            border-left: 3px solid #ddd;
            padding-left: 1em;
            margin: 1em 0;
            font-style: italic;
            color: #555;
        }

        ul, ol {
            margin-left: 2em;
            margin-bottom: 1em;
        }

        li {
            margin-bottom: 0.5em;
        }

        .subtitle {
            font-style: italic;
            font-size: 1.1em;
            line-height: 1.4;
            color: #555;
            margin-bottom: 0.2em;
        }

        .date {
            color: #666;
            font-style: italic;
            font-size: 0.9em;
            margin-bottom: 1em;
        }

        footer {
            margin-top: 3em;
            padding-top: 1em;
            border-top: 1px solid #ddd;
            font-size: 0.9em;
            color: #666;
        }

        /* LaTeX math blocks */
        .katex-display {
            margin: 1.5em 0;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* Footnotes styling */
        .footnote {
            font-size: 0.9em;
        }

        .footnotes {
            margin-top: 3em;
            padding-top: 1em;
            border-top: 1px solid #ddd;
            font-size: 0.9em;
        }

        sup {
            line-height: 0;
        }

        /* Mobile optimization */
        @media (max-width: 480px) {
            body {
                padding: 10px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/">← kamilelukosiute.com</a>
        </header>

        <article>
            <h1>Design for the defenders you care about or risk being useless</h1>
            <p class="subtitle">On operational constraints of critical infrastructure providers and the limits of AI-powered vulnerability discovery</p>
            <p class="date">Dec 8, 2025</p>
            <p>AI systems are getting genuinely good at finding software vulnerabilities. That’s not necessarily good news for everyone.</p>
<p>Research and product teams are building systems that find zero-days, and we are all very excited. Find vulnerabilities before attackers do; patch them; systems are more secure, yay.</p>
<p>Nevertheless, we’re all a little <em>too</em> excited about vulnerability discovery. As <a href="https://ifp.org/operation-patchlight/">has been noted before</a>, vulnerability discovery only helps improve the state of cybersecurity if the discovered vulnerabilities have patches written, tested, and deployed in all the places where a given piece of code is used in a timely manner.</p>
<p>This is not so easy to do in the real world. In the real world, patches have to be tested for compatibility, maintenance windows have to be negotiated, and systems have to be rebooted to apply patches. In the real world, no one wants to interrupt patient care or power delivery for an invisible threat.</p>
<p>I’m hopeful that we can automate this whole process in a way that doesn’t force organizations to choose between uptime and security, perhaps through some combination of <a href="https://arxiv.org/pdf/2203.12132v1">runtime patching</a> and <a href="https://docs.gitlab.com/user/duo_agent_platform/agents/foundational_agents/security_analyst_agent/">AI triage and prioritization</a>, integration testing, and deployment. But full automation is a long way off, and in the meantime, already vulnerable organizations will have to deal with increasing threats from AI-enabled cyberattacks.</p>
<p>If organizations can't actually patch the vulnerabilities AI discovers, attackers will be the main beneficiaries of better discovery tools. Defenders need AI tools that go beyond vulnerability discovery. Taking into account the real-world operational challenges faced by the defenders we care about is the only way to make sure that whatever we build with AI in cybersecurity ends up benefiting defense more than offense.</p>
<h2>The vulnerability lifecycle<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup></h2>
<p>To understand my argument, it helps to trace the full path of a vulnerability.</p>
<p>Software vulnerabilities are flaws in code that attackers can exploit to gain unauthorized access or compromise a system. Most modern software is riddled with them, and <a href="https://www.sciencedirect.com/science/article/abs/pii/S0167404823001013">there's no way to know when you've found the last one</a>. This creates an asymmetry: defenders have to find and fix <em>every</em> exploitable flaw, while attackers only need to find one.</p>
<p>As Caleb Withers puts it in his <a href="https://s3.us-east-1.amazonaws.com/files.cnas.org/documents/Report_Tipping-the-Scales_TECH_Sep-2025-Final.pdf">excellent report on offense defense balance</a>, "It is currently impractical to find and fix them all [...]. Rather than aiming for 100 percent vulnerability-free systems, defenders can only hope that by discovering and addressing the most critical vulnerabilities, whatever they miss is sufficiently difficult for attackers to find and exploit."</p>
<p>The promise of AI-driven vulnerability discovery is that it might even out this asymmetry. Research labs and startups are building systems designed to find vulnerabilities at scale, at various parts of the software lifecycle, such as during development, in pre-release audits, and on deployed systems. <a href="https://openai.com/index/introducing-aardvark/">OpenAI’s Aardvark</a> is embedded directly into development pipelines to scan commits as they happen, validate whether findings are actually exploitable, and propose patches. <a href="https://googleprojectzero.blogspot.com/2024/10/from-naptime-to-big-sleep.html">Google’s Big Sleep</a> project uses LLMs to do variant analysis: given a past vulnerability, it looks for similar bugs in a codebase. The AI system found an exploitable SQLite vulnerability before the bug ever reached a release. And <a href="https://xbow.com/">XBOW</a> automates penetration testing, or simulations of real attacks against deployed systems. Their agents work to discover and exploit vulnerabilities in running applications.</p>
<p>But finding a vulnerability is only the first part of its story. Once one is found, someone has to write a patch for it. Then that patch has to be deployed to every system running the vulnerable code. The patching step is not trivial.</p>
<p>Imagine you learn about a new vulnerability affecting your systems. Hopefully, a vendor has already released a patch you can use. You first have to decide how dangerous the vulnerability is for your systems and whether it’s worth your effort to patch it.  If you decide to go ahead with patching, you must then test the compatibility of the patch with the rest of the systems. Then, you need to actually deploy the patch. Maybe your organization has routine maintenance windows, but you need to decide whether the risk from the vulnerability is sufficiently low that you can wait until then. Or maybe there are no maintenance windows. In any case, you’ll have to coordinate with the rest of your organization as to when you’ll be able to actually have the time to do the patching. And after all that, you’ll have to test the patch and make sure that all went as expected.</p>
<p>It’s very likely that you’ll run into issues at some point in this process. Patches might have dependencies on other software that cause compatibility problems. Testing might reveal errors that require troubleshooting. Deployment might fail and require rollbacks. And even when everything works technically, you’ll still have to do a bunch of human coordination: patch deployment usually requires reboots, reboots cause downtime, and getting approval for downtime from customers or upper management takes time. In healthcare organizations, for example, <a href="https://arxiv.org/pdf/2202.09016">it seems that the majority of patching delays</a> occur during the deployment phase, and the most common cause of delays overall is coordination.</p>
<p>On the whole, patching is an annoying process, and even well-resourced organizations have to make trade-offs about how often to do it and which patches to prioritize. For organizations with little tolerance for downtime, such as <a href="https://arpa-h.gov/news-and-events/arpa-h-announces-program-automate-cybersecurity-health-care-facilities#:~:text=taking%20a%20critical%20piece%20of%20hospital%20infrastructure%20offline%20for%20updates%20can%20be%20very%20disruptive">hospitals that operate 24/7</a> or <a href="https://digital.txone.com/media/txone-networks-2024-annual-ics-ot-cybersecurity-report/prioritizing-vulnerabilities-and-overcoming-patching-challenges#:~:text=especially%20in%20industries%20such%20as%20manufacturing%20and%20energy%2C%20where%20business%20continuity%20is%20of%20paramount%20importance%2E">factories where uptime == revenue</a>, patching is at direct odds with their operational goals.</p>
<p>Because of the difficulty of the patching process, there is a lag between when a patch is made available to a user and when an end user patches it. Verizon's annual <a href="https://www.verizon.com/business/resources/reports/2024-dbir-data-breach-investigations-report.pdf">Data Breach Investigations Report</a> found that it takes around 55 days after a patch has been made available to remediate 50% of critical, actively exploited vulnerabilities.<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>
<img src="/images/verizon_dbir.png" style="max-width: 500px" alt="verizon_dbir.png">
<em>Survival analysis of vulnerabilities. Even critical, actively exploited vulnerabilities take months to patch. Source: <a href="https://www.verizon.com/business/resources/reports/2024-dbir-data-breach-investigations-report.pdf">Verizon DBIR 2024</a></em></p>
<p>For comparison, the mean time to exploit a vulnerability once it has been publicly disclosed is <a href="https://cloud.google.com/blog/topics/threat-intelligence/time-to-exploit-trends-2023">around 5 days</a>. In other words, on average, by the time half of vulnerable systems are patched, attackers have had nearly two months to exploit them.  </p>
<p>Finding more vulnerabilities doesn't help improve security if the bottleneck is patching capacity. If AI gets better at finding vulnerabilities, under-resourced organizations are worse off. They'll have more vulnerabilities to deal with and the same strained patching processes. We're seeing a similar dynamic play out with <a href="https://thenewstack.io/ffmpeg-to-google-fund-us-or-stop-sending-bugs/">open source maintainers</a><sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup>, who say they can't keep up with AI-discovered bugs.</p>
<h2>Designing for constraints</h2>
<p>Organizations face constraints: in operations, in funding, in personnel, in legal obligations. To actually improve cybersecurity in the real world, AI solutions should be designed with the constraints of their intended users in mind.</p>
<p>We may wish that the world were a certain way, where patching was easy, where organizations didn’t still use Windows XP<sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup>, where we knew which vulnerabilities were actually the most critical, where we could replace inherently insecure devices once alternatives became available. But that's not the world we live in. If proposed AI solutions don't account for this, they will be of no use to the institutions that actually need help.</p>
<p>Some of this is just lock-in. Banks <a href="http://c">still run mainframes</a> because rewriting decades of COBOL isn't something anyone actually wants to do. Utilities and manufacturing plants run SCADA systems built to last decades, never meant to be networked,<sup id="fnref:5"><a class="footnote-ref" href="#fn:5">5</a></sup> but now they are. Even if you believe that organizations like these will eventually be fully automated, there's a long time between now and "eventually" when critical infrastructure remains vulnerable. But there’s useful work to do now, and security practitioners already have precedent for thinking like this.  </p>
<p>There's a concept called <a href="https://www.fortinet.com/resources/cyberglossary/compensating-controls">compensating controls</a>: security measures you put in place when you can't fix the underlying problem. In ICS/OT<sup id="fnref:6"><a class="footnote-ref" href="#fn:6">6</a></sup> environments, <a href="https://www.fortinet.com/resources/cyberglossary/virtual-patching">virtual patching</a> is a common example. When a vulnerability is disclosed, operators deploy firewall rules within hours to block exploitation while the real patch gets developed, tested, and scheduled for the next maintenance window.<sup id="fnref:7"><a class="footnote-ref" href="#fn:7">7</a></sup> These solutions recognize that OT operators don't have the same flexibility in patching that IT teams do. Similarly, <a href="https://www.beyondtrust.com/resources/glossary/privileged-access-management-pam">Privileged Access Management solutions</a> exist in part because we can't quite yet get rid of shared accounts, hardcoded credentials, and default passwords.</p>
<p>AI opens up new avenues for this kind of constraint-aware design. GitLab has a <a href="https://docs.gitlab.com/user/duo_agent_platform/agents/foundational_agents/security_analyst_agent/">Security Analyst Agent</a> that tries to help with vulnerability triage, false positive assessment, and remediation planning. I’d be really excited to see similar technologies built for other platforms. I’d also be excited to see frontier LLM cyber capabilities thrown at all of the following parts of the vulnerability lifecycle in earnest<sup id="fnref:8"><a class="footnote-ref" href="#fn:8">8</a></sup>:</p>
<ul>
<li>Asset inventory and attack surface discovery tools    </li>
<li>Vulnerability prioritization + triage (for developing a patch in the first place)</li>
<li>Patch prioritization + triage (for organizations deploying vendor patches)</li>
<li>Automated network topology analysis to determine which of your vulnerabilities are actually critical given your specific configuration</li>
<li>Systems that simulate patch rollouts to predict compatibility issues before you commit</li>
<li>Optimal scheduling tools that minimize downtime while maximizing patch coverage</li>
<li>Monitoring systems that detect whether your unpatched vulnerabilities are being actively exploited</li>
</ul>
<h2>Conclusion</h2>
<p>To be clear, I'm <em>also</em> excited about AI-driven vulnerability discovery. For well-resourced organizations with mature security teams and flexible maintenance windows, it's going to be genuinely useful. We should keep building it. But AI vulnerability discovery is just going to happen: the market incentives are there, and the technology is already emerging.</p>
<p>What I want more of is the stuff that won't happen by default: tools designed for the stressed-out hospital IT team, the understaffed utility company, the organizations where "just patch it" isn't a realistic answer. The promise of AI is that it can make labor-intensive work cheap enough to help everyone. But for critical infrastructure and under-resourced organizations, that's only going to happen with government or philanthropic support. The market isn't big enough, and they don't have the budgets to attract commercial interest.</p>
<p>I don't know exactly what this technology will look like, and I’m probably wrong about the real constraints these organizations face. But the design principle remains: design for the constraints of the defenders you care about, or risk being useless (or worse: actively detrimental).</p>
<p>If we’re serious about using AI to improve security, we have to design for the world as it is.</p>
<p><em>Thank you to E.T.J., Adam Swanda, and GovAI research staff for feedback on a draft of this post.</em></p>
<h2>Appendix: Medical and Operational Technology Devices</h2>
<p>Everything above is about IT systems. When I talk about downtime for hospitals or utilities, I'm still talking about their IT layer. But there are two other classes of particularly vulnerable technologies in use by CI providers: medical devices (MRI machines, infusion pumps, pacemakers) and OT devices (PLCs controlling power plants, SCADA systems in manufacturing). These devices are particularly scary attack vectors because they're the interface between the cyber and physical worlds. A tampered infusion pump means a patient actually harmed. A hijacked PLC means changing the flow of water or chemicals or worse.</p>
<p>They share three properties that make them even harder to patch than regular IT:</p>
<ol>
<li><strong>Long designed lifespans.</strong> The <a href="https://www.ic3.gov/CSA/2022/220912.pdf">FBI notes</a> that medical device hardware often remains active for 10-30 years. OT systems are <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-82r3.pdf">similar</a>, designed to last decades.</li>
<li><strong>Legacy software.</strong> Both <a href="https://www.ic3.gov/CSA/2022/220912.pdf">medical devices</a> and <a href="https://digital.txone.com/media/txone-networks-2024-annual-ics-ot-cybersecurity-report/prioritizing-vulnerabilities-and-overcoming-patching-challenges">OT systems</a> run on operating systems that are long past end-of-life and will never receive another patch from the vendor.</li>
<li><strong>Patching requires downtime.</strong> And downtime means <a href="https://www.usenix.org/system/files/usenixsecurity25-kustosch-patching.pdf">patients don't get care</a> or <a href="https://digital.txone.com/media/txone-networks-2024-annual-ics-ot-cybersecurity-report/prioritizing-vulnerabilities-and-overcoming-patching-challenges">production stops</a>. 
These factors leave medical care providers and OT users exposed. But they also don't seem to be getting attacked much. An <a href="https://405d.hhs.gov/Documents/405d-hospital-resiliency-analysis.pdf">HHS report</a> writes: "threat intelligence and breach data suggest medical devices are not a prominent attack vector for adversaries to disrupt hospital operations." OT devices have a bit more of a track record. <a href="https://en.wikipedia.org/wiki/Stuxnet">Stuxnet</a> remains the canonical example of what's possible, and more recently, Iran-affiliated actors <a href="https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-335a">targeted Israeli-made PLCs</a> in U.S. water facilities. But the descriptions of these attacks make it sound like <a href="https://www.waterworld.com/water-utility-management/article/14302077/aliquippa-pennsylvania-suffers-cyberattack-on-booster-station-plc">maybe it wasn’t a huge deal</a>, often not impacting operations at all. OT attacks are currently rare, resource-intensive, and not scalable cybercrime.</li>
</ol>
<p>So should medical and OT devices be a top priority? Not today, not really.<sup id="fnref:9"><a class="footnote-ref" href="#fn:9">9</a></sup> But the calculus might change really quickly. <a href="https://assets.anthropic.com/m/ec212e6566a0d47/original/Disrupting-the-first-reported-AI-orchestrated-cyber-espionage-campaign.pdf">Anthropic's recent report</a> of a Chinese-affiliated group using Claude to execute 80-90% of a sophisticated cyber espionage campaign shows that we're very close to autonomous hackers, much faster and much cheaper than human labor. If attack costs drop far enough, the current logic of "not worth the effort" could shift. Maybe right now the ROI of attacking a few medical devices is insufficiently disruptive for an adversary, but if you can just launch automated agents to do it, maybe we'll see more of that. And then the lifespan, legacy, and patching problems for these devices are really going to come back to bite us.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>I highly recommend reading <a href="https://cset.georgetown.edu/article/ai-and-the-software-vulnerability-lifecycle/">Chris Rohlf’s excellent blog post</a> for more details on many of the steps I gloss over.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Specifically, vulnerabilities in CISA’s <a href="https://www.cisa.gov/known-exploited-vulnerabilities-catalog">Known Exploited Vulnerabilities Catalog</a>.&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>The bottleneck I describe above is in patch deployment, where the patch is provided by a vendor; for open source projects, it's often patch creation itself. Volunteer maintainers write the patches for open source libraries.&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>See <a href="https://commerce.idaho.gov/content/uploads/2021/09/TLP-AMBER_Energy-Cyber-Risk-Summary.pdf">CISA Cyber Risk Summary: Energy Sector</a> in 2020: “24% of enrolled Energy Sector entities ran unsupported Windows operating systems (OSs) that no longer receive routine security updates on at least one internet-accessible host at the end of Q4 of 2020.”&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>See <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-82r3.pdf">NIST SP 800-82r3 (Guide to OT Security)</a>: “Initially, OT had little resemblance to traditional information technology (IT) systems because OT systems were isolated, ran proprietary control protocols, and used specialized hardware and software.” (p. 28); “The lifespan of an OT system can exceed 20 years. “ (pg. 37)&#160;<a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Industrial Control Systems / Operational Technology&#160;<a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>Virtual patching doesn’t cover all attack vectors and attackers <a href="https://www.giac.org/paper/gcia/12447/methods-controlled-deployment-operation-virtual-patching-program/143808">can evolve around them</a>, which is why it’s not a permanent solution.&#160;<a class="footnote-backref" href="#fnref:7" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:8">
<p>Credit to E.T.J. and A.S. for some of these ideas.&#160;<a class="footnote-backref" href="#fnref:8" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:9">
<p>One piece of evidence for "yes, this matters”, though, is that <a href="https://arpa-h.gov/news-and-events/upgrade-launches-fortify-medical-devices-against-cyber-threats">ARPA-H is pouring $43 million</a> into tools for hospitals to detect and remediate vulnerabilities in medical devices. Maybe they're just AI-pilled, or maybe they see something I don’t.&#160;<a class="footnote-backref" href="#fnref:9" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
</ol>
</div>
        </article>

        <footer>
            <p><a href="/posts/">← All posts</a></p>
        </footer>
    </div>

    <!-- Initialize KaTeX auto-render -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ],
                throwOnError: false
            });
        });
    </script>
</body>
</html>
